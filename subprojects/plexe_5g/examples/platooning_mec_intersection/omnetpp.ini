[General]
cmdenv-express-mode = true
cmdenv-autoflush = true
cmdenv-status-frequency = 10s
num-rngs = 9

ned-path = .
network = PlatooningIntersectionMEC
eventlog-file=${resultdir}/${configname}-${repetition}.elog
snapshot-file=${resultdir}/${configname}-${repetition}.sna

repeat = 1

##########################################################
#            Simulation parameters                       #
##########################################################
debug-on-errors = true
print-undisposed = true

*.playgroundSizeX = 65000m
*.playgroundSizeY = 25000m
*.playgroundSizeZ = 50m

sim-time-limit = 360 s

##########################################################
# Annotation parameters                                  #
##########################################################
*.annotations.draw = false

##########################################################
# Obstacle parameters                                    #
##########################################################
*.obstacles.debug = false

##########################################################
#            WorldUtility parameters                     #
##########################################################
*.world.useTorus = false
*.world.use2D = false

##########################################################
#            TraCIScenarioManager parameters             #
##########################################################
*.manager.updateInterval = 0.01s
*.manager.host = "localhost"
*.manager.moduleType = "org.car2x.plexe.subprojects.plexe_5g.PlatoonCarNR"
*.manager.moduleName = "node"
*.manager.moduleDisplayString = ""
*.manager.autoShutdown = true
*.manager.margin = 25

##########################################################
#            11p specific parameters                     #
#                                                        #
#                    NIC-Settings                        #
##########################################################
*.connectionManager.sendDirect = true
*.connectionManager.maxInterfDist = 2600m
*.connectionManager.drawMaxIntfDist = false

*.**.nic.mac1609_4.useServiceChannel = false

*.**.nic.mac1609_4.txPower = 100mW
*.**.nic.mac1609_4.bitrate = 6Mbps

*.**.nic.mac1609_4.useAcks = true
*.**.nic.mac1609_4.ackErrorRate = 0.0
*.**.nic.mac1609_4.frameErrorRate = 0.0

*.**.nic.phy80211p.minPowerLevel = -94dBm
*.**.nic.phy80211p.maxTXPower = 100mW
*.**.nic.phy80211p.useNoiseFloor = true
*.**.nic.phy80211p.noiseFloor = -95dBm
*.**.nic.phy80211p.decider = xmldoc("config.xml")
*.**.nic.phy80211p.analogueModels = xmldoc("config.xml")
*.**.nic.phy80211p.usePropagationDelay = true

##########################################################
#          Mobile network specific parameters            #
##########################################################

############### SCTP configuration ##################
**.sctp.nagleEnabled = false         # if true, transmission of small packets will be delayed on the X2
**.sctp.enableHeartbeats = false

############### General PHY parameters ##############
#**.downlink_interference = true
#**.uplink_interference = true
**.ueTxPower = 26dBm
**.eNodeBTxPower = 46dBm
**.targetBler = 0.01
**.blerShift = 5
**.fbPeriod = 40tti   # reports CQI every 40ms

############### IPv4 configurator config #################
# although there exists Ipv4NodeConfigurator, the module cannot assign IPs to dynamically generated nodes
# for such reason, it is necessary to use HostAutoConfigurator
*.node[*].ipv4.configurator.typename = "inet.networklayer.configurator.ipv4.HostAutoConfigurator"
# this parameter has nothing to deal with the name of the submodule "cellularNic"
# it is a name the interface is registered with in inet. By default, in IP2Nic, the name is set to "cellular"
*.node[*].ipv4.configurator.interfaces = "cellular"
*.node[*].ipv4.configurator.addressBase = "10.0.0.0"
*.node[*].ipv4.configurator.netmask = "255.0.0.0"
*.node[*].ipv4.configurator.mcastGroups = "224.0.0.1"

# tcp settings
**.tcp.typename = "Tcp"
**.tcp.advertisedWindow = 65535         # in bytes, corresponds with the maximal receiver buffer capacity (Note: normally, NIC queues should be at least this size)
**.tcp.tcpAlgorithmClass = "TcpReno"    # TcpReno/TcpTahoe/TcpNewReno/TcpNoCongestionControl/DumbTcp
**.tcp.sackSupport = true               # Selective Acknowledgment (RFC 2018, 2883, 3517) support (header option) (SACK will be enabled for a connection if both endpoints support it)


############### CA configuration #################
*.carrierAggregation.numComponentCarriers = 1
*.carrierAggregation.componentCarrier[0].numerologyIndex = ${u=0}
*.carrierAggregation.componentCarrier[0].carrierFrequency = 2GHz
*.carrierAggregation.componentCarrier[0].numBands = ${numRbs=50}

*.gnb*.cellularNic.numCarriers = 1
*.gnb*.cellularNic.channelModel[0].componentCarrierIndex = 0
*.node[*].cellularNic.numCarriers = 1
*.node[*].cellularNic.nrChannelModel[0].componentCarrierIndex = 0

############### BS position #################
*.gnb*.mobility.initFromDisplayString = false

*.gnb1.mobility.initialX = 0m
*.gnb1.mobility.initialY = 224m
*.gnb2.mobility.initialX = 1400m
*.gnb2.mobility.initialY = 224m

############### X2 configuration #################
*.gnb*.numX2Apps = 1                                        # one x2App per peering node
*.gnb*.x2App[*].server.localPort = 5000 + ancestorIndex(1)  # Server ports (x2App[0]=5000, x2App[1]=5001, ...)
*.gnb1.x2App[0].client.connectAddress = "gnb2%x2ppp0"
*.gnb2.x2App[0].client.connectAddress = "gnb1%x2ppp0"

############## UE configuration ##################
# UEs associates to the best BS at the beginning of the simulation
# Enable dynamic association of UEs (based on best SINR)
*.node[*].masterId = 0     # ignored if dynamic association is disabled
*.node[*].macCellId = 0    # ignored if dynamic association is disabled
*.node[*].nrMasterId = 1     # ignored if dynamic association is disabled
*.node[*].nrMacCellId = 1    # ignored if dynamic association is disabled
**.dynamicCellAssociation = true
**.enableHandover = true

*.gnb*.cellularNic.phy.handoverLatency = 50ms
*.gnb*.cellInfo.broadcastMessageInterval = 1s # eNB will sends broadcast triggers every second

# eNodeB configuration
**.gnb1.macCellId = 1
**.gnb1.macNodeId = 1
**.gnb2.macCellId = 2
**.gnb2.macNodeId = 2

### Enable D2D for the eNodeB and the UEs involved in direct communications ###
**.amcMode = "D2D"

### Select CQI for D2D transmissions ###
# One-to-Many communications work with fixed CQI values only.
# Set the parameter **.usePreconfiguredTxParams and select the desired CQI using the parameter **.d2dCqi
**.enableD2DCqiReporting = false
**.usePreconfiguredTxParams = true
**.d2dCqi = ${cqi=7}


############ MEC Configuration ############


# MEC Hosts
**.mecHost*.virtualisationInfrastructure.ipv4.forwarding = true
*.mecHost*.maxMECApps = 100					# max ME Apps to instantiate
*.mecHost*.maxRam = 32GB					# max KBytes of Ram
*.mecHost*.maxDisk = 100TB					# max KBytes of Disk Space
*.mecHost1.maxCpuSpeed = 400000		    	# max CPU
*.mecHost2.maxCpuSpeed = 500				# max CPU

*.mecHost*.bsList = ["gnb1", "gnb2"]

# MEC Services
# MEC host 1 services configurations
*.mecHost1.mecPlatform.numMecServices = 0
*.mecHost1.mecPlatform.mecService[0].typename = "LocationService"
*.mecHost1.mecPlatform.mecService[0].localAddress = "mecHost1.virtualisationInfrastructure"
*.mecHost1.mecPlatform.mecService[0].localPort = 10020
*.mecHost1.mecPlatform.serviceRegistry.localAddress = "mecHost1.virtualisationInfrastructure"
*.mecHost1.mecPlatform.serviceRegistry.localPort = 10021


# MEC host 2 services configurations
*.mecHost2.mecPlatform.numMecServices = 1
*.mecHost2.mecPlatform.mecService[0].typename = "LocationService"
*.mecHost2.mecPlatform.mecService[0].localAddress = "mecHost2.virtualisationInfrastructure"
*.mecHost2.mecPlatform.mecService[0].localPort = 10020
*.mecHost2.mecPlatform.serviceRegistry.localAddress = "mecHost2.virtualisationInfrastructure"
*.mecHost2.mecPlatform.serviceRegistry.localPort = 10021

# random number generators configuration
# TODO: fix to avoid clashing with oder RNGs
*.mecHost2.mecPlatform.serviceRegistry.rng-0 = 0 # request service time
*.mecHost2.mecPlatform.serviceRegistry.rng-1 = 1 # subscription service time
*.mecHost2.mecPlatform.mecService[0].rng-0 = 0 # request service time
*.mecHost2.mecPlatform.mecService[0].rng-1 = 1 # subscription service time
*.mecHost2.mecPlatform.mecService[0].requestServiceTime = 20us
*.mecHost2.mecPlatform.mecService[0].subscriptionServiceTime = 11us

# MEC Orchestrator configuration
*.mecOrchestrator.mecHostList = ["mecHost1", "mecHost2"]              # MEC hosts associated to the MEC system
*.mecOrchestrator.selectionPolicy = ${mecHostSelectionPolicy= "MecServiceBased"}
*.mecOrchestrator.mecHostIndex = 1
*.mecHost*.mecPlatformManager.mecOrchestrator = "mecOrchestrator" # the MECPM needs to know the MEC orchestrator
















##########################################################
#                      Mobility                          #
##########################################################
*.node[*].mobility.x = 0
*.node[*].mobility.y = 0
*.node[*].mobility.z = 1.895
*.node[*].mobility.initFromDisplayString = true

*.node[*].traciMobility.x = 0
*.node[*].traciMobility.y = 0
*.node[*].traciMobility.z = 1.895

##########################################################
#                    Seeds and PRNGs                     #
##########################################################
seed-set = ${repetition}
**.seed = ${repetition}

*.node[*].prot.rng-0 = 5
*.node[*].appl.rng-0 = 6
*.node[*].scenario.rng-0 = 7
**.traffic.rng-0 = 8


#launch config. tells Veins which SUMO configuration to run
*.manager.configFile = "./sumocfg/intersection.sumocfg"			#indy.sumo.cfg
*.manager.launchConfig = xmldoc("./sumocfg/indy.launchd.xml")  #indy

##########################################################
#                   Common parameters                    #
##########################################################

**.numberOfCars = ${nCars = 8}
**.numberOfCarsPerPlatoon = ${platoonSize = 4}
**.numberOfLanes = ${nLanes = 1}

##########################################################
#                    Position helper                     #
##########################################################

*.node[*].helper_type = "PositionHelper"

##########################################################
#               Scenario common parameters               #
##########################################################

#controller and engine related parameters
*.node[*].scenario.caccC1 = 0.5
*.node[*].scenario.caccXi = 1
*.node[*].scenario.caccOmegaN = 0.2 Hz
*.node[*].scenario.engineTau = 0.5 s
*.node[*].scenario.ploegH = 0.5s
*.node[*].scenario.ploegKp = 0.2
*.node[*].scenario.ploegKd = 0.7
*.node[*].scenario.useRealisticEngine = false
#via wireless send acceleration computed by the controller, not the actual one
*.node[*].scenario.useControllerAcceleration = true
*.node[*].scenario.nLanes = ${nLanes}

#controllers to be tested
**.numericController = ${controller = 1}
*.node[*].scenario.targetController = ${sController = "CACC"! controller}

#headway for ACCs
**.headway = ${headway = 0.1 ! controller}s
*.node[*].scenario.accHeadway = ${headway}s
*.node[*].scenario.leaderHeadway = ${leaderHeadway = 1.2}s

#average leader speed
*.node[*].scenario.leaderSpeed = ${leaderSpeed = 50}kmph

##########################################################
#                      Application                       #
##########################################################

*.node[*].appl_type = "GeneralPlatooningApp"
#enable statistics recording for the application
*.node[*].appl.*.scalar-recording = true
*.node[*].appl.*.vector-recording = false
#use the join at back implementation of the join maneuver
*.node[*].appl.joinManeuver = "JoinAtBack"
*.node[*].appl.mergeManeuver = "MergeAtBack"

# add simple platooning app to manage beacons to be sent to the CACC
*.node[*].numPlexeApps = 1
*.node[*].plexeApp[0].typename = "SimplePlatooningApp"

##########################################################
#                Communication protocols                 #
##########################################################

*.node[*].protocol_type = "SimplePlatooningBeaconing"
#enable statistics recording for the network layer
*.node[*].prot.*.scalar-recording = false
*.node[*].prot.*.vector-recording = false
#set the beaconing interval to be 0.1s
*.node[*].prot.beaconingInterval = 0.1s
#access category for platooning beacons
*.node[*].prot.priority = 4
#packet size for platooning beacon
*.node[*].prot.packetSize = 200

##########################################################
#                    Traffic manager                     #
##########################################################

***.traffic_type = "org.car2x.plexe.subprojects.plexe_5g.IntersectionTrafficManager"
#insert platooning vehicles at time
**.traffic.platoonInsertTime = 1 s
#insert platooning vehicles with a speed of
**.traffic.platoonInsertSpeed = ${leaderSpeed}kmph
#SUMO vtype for platooning vehicles
**.traffic.platooningVType = "vtypeauto"
**.traffic.shockwaveVType = "shockwave"
**.traffic.injectShockwaveCars = false

#controllers to be tested
#**.numericController = ${controller = 0}           #-----------------
*.traffic.controller = ${"CACC" ! controller}     #-----------------
#insert vehicles already at steady-state. distance depends on controller
**.traffic.platoonInsertDistance = ${5 ! controller}m
**.traffic.platoonInsertHeadway = ${0 ! controller}s
**.traffic.platoonLeaderHeadway = ${leaderHeadway}s

#if not random insert
**.traffic.platoonSizeA = 3
**.traffic.platoonSizeB = 4
**.traffic.platoonSizeC = 5
**.traffic.initialPositionDeltaA = 0
**.traffic.initialPositionDeltaB = 20
**.traffic.initialPositionDeltaC = 0


# routes 
**.traffic.routeLeftRight = "west_east"
**.traffic.routeBottomRight = "south_east"
**.traffic.routeRightLeft = "east_west"


##########################################################
#                       INET stack                       #
##########################################################

# each car has a device app to instantiate the MEC app, and the UE Traffic Authority App
*.node[*].numApps = 2

*.node[*].app[0].typename = "DeviceApp"
*.node[*].app[0].localPort = 4500
*.node[*].app[0].ualcmpAddress = "ualcmp"
*.node[*].app[0].ualcmpDestPort = 1000
 
*.node[*].app[1].typename = "UEIntersectionMergeApp"
*.node[*].app[1].deviceAppAddress = "node["+string(ancestorIndex(1))+"]"
*.node[*].app[1].deviceAppPort = 4500
*.node[*].app[1].startTime = 2s
# stop time is currently not used
*.node[*].app[1].stopTime = 120s
# name of the global module helping the translation from vehicle ID to IP address
*.node[*].app[1].idipModule = "idip"
######## ---------------ADDED FROM ORIGINAL-------
#road and distance eval parameters
*.node[*].app[1].commonEdge = "E1"
*.node[*].app[1].distanceThreshold = 500 m
*.node[*].app[1].distanceInterval = 0.2 s
*.node[*].app[1].holdingPosition = 1085 m
*.node[*].app[1].holdingAcceleration = -2 mpsps


*.node[*].app[1].*.scalar-recording = true
*.node[*].app[1].*.vector-recording = true


*.mecHost*.MEC*IntersectionMergeApp*.*.scalar-recording = true
*.mecHost*.MEC*IntersectionMergeApp*.*.vector-recording = true
#------------------------------------#

# the old traffic authority is left just for old reference but it is not used
# it is now substituted by the MECTrafficAuthorityApp
*.trafficAuthority.numApps = 1
*.trafficAuthority.app[0].typename = "PlatoonTrafficAuthority"
*.trafficAuthority.app[0].localPort = 3000

**.matlab.vector-recording = true
**.matlab.*.vector-recording = true

**.matlab.matlabSessionName = "plexe"

#disable statistics recording for all other modules
**.scalar-recording = false
**.vector-recording = false

[Config BaselineIntersectionMerge]
*.manager.command = "sumo-gui"

*.mecHost*.MEC*IntersectionMergeApp*.baseline = true
*.mecHost*.MEC*IntersectionMergeApp*.delay = -1s

*.mecHost*.MEC*IntersectionMergeApp*.platoonNum = 3
*.mecHost*.MEC*IntersectionMergeApp*.safetyDistance = 7 m
*.mecHost*.MEC*IntersectionMergeApp*.maxAcc = 2.5 mpsps
*.mecHost*.MEC*IntersectionMergeApp*.maxSpeed = 16.67 mps

# TODO: find suitable parameters set
# initial positions of A and B:
# "0 0" both platoons at the most possible west position
# "0 20" platoons as close as possible but both of them shifted to the east by 20 meters
# "20 0" first platoon 20 meters ahead of the closest possible position, second platoon as far west as possible
#**.traffic.initialPositionDeltaA = ${initialPositionDeltaA = 0, 20, 40}
#**.traffic.initialPositionDeltaB = ${initialPositionDeltaB = 0..160 step 40}
#**.traffic.initialPositionDeltaC = ${initialPositionDeltaC = 0..180 step 30}

**.traffic.initialPositionDeltaA = ${initialPositionDeltaA = 0, 10, 20}
**.traffic.initialPositionDeltaB = ${initialPositionDeltaB = 760..900 step 20}
**.traffic.initialPositionDeltaC = ${initialPositionDeltaC = 800..900 step 20}

#use the base scenario
*.node[*].scenario_type = "SimpleScenario"

*.mecOrchestrator.mecApplicationPackageList = ["BaselineIntersectionMergeApp"]   # List of MEC app descriptors to be onboarded at
*.node[*].app[1].mecAppName = "MECBaselineIntersectionMergeApp"
*.node[*].app[0].appPackageSource = "ApplicationDescriptors/BaselineIntersectionMergeApp.json"

*.node[*].app[1].usePeriodicUpdates = false
*.node[*].app[1].intersectionUpdateInterval = 1s

output-vector-file = ${resultdir}/${configname}_${initialPositionDeltaA}_${initialPositionDeltaB}_${initialPositionDeltaC}_${repetition}.vec
output-scalar-file = ${resultdir}/${configname}_${initialPositionDeltaA}_${initialPositionDeltaB}_${initialPositionDeltaC}_${repetition}.sca

[Config BaselineIntersectionMergeNoGui]
extends = BaselineIntersectionMerge

*.manager.command = "sumo"
*.manager.ignoreGuiCommands = true
#force the config name in the output file to be the same as for the gui experiment
output-vector-file = ${resultdir}/BaselineIntersectionMerge_${initialPositionDeltaA}_${initialPositionDeltaB}_${initialPositionDeltaC}_${repetition}.vec
output-scalar-file = ${resultdir}/BaselineIntersectionMerge_${initialPositionDeltaA}_${initialPositionDeltaB}_${initialPositionDeltaC}_${repetition}.sca

[Config IntersectionMerge]
extends = BaselineIntersectionMerge

repeat = 1

*.mecOrchestrator.mecApplicationPackageList = ["MatlabIntersectionMergeApp"]   # List of MEC app descriptors to be onboarded at
*.node[*].app[1].mecAppName = "MECMatlabIntersectionMergeApp"
*.node[*].app[0].appPackageSource = "ApplicationDescriptors/MatlabIntersectionMergeApp.json"

*.node[*].app[1].usePeriodicUpdates = true
*.node[*].app[1].intersectionUpdateInterval = 1s

**.dummyDelay = ${dummyDelay = 0, 1, 2, 3, 4}
*.mecHost*.MEC*IntersectionMergeApp*.delay = ${-1s, uniform(0.1s, 0.2s), uniform(0.2s, 0.5s), uniform(0.5s, 1s), uniform(1s, 2s) ! dummyDelay}
*.mecHost*.MEC*IntersectionMergeApp*.maxSpeed = ${maxSpeed = 13.89, 16.67} mps
#*.mecHost*.MEC*IntersectionMergeApp*.maxSpeed = ${maxSpeed = 13.89}

*.manager.command = "sumo-gui"
#force the config name in the output file to be the same as for the gui experiment
output-vector-file = ${resultdir}/${configname}_${initialPositionDeltaA}_${initialPositionDeltaB}_${initialPositionDeltaC}_${dummyDelay}_${maxSpeed}_${repetition}.vec
output-scalar-file = ${resultdir}/${configname}_${initialPositionDeltaA}_${initialPositionDeltaB}_${initialPositionDeltaC}_${dummyDelay}_${maxSpeed}_${repetition}.sca


[Config IntersectionMergeNoGui]
extends = IntersectionMerge

*.manager.command = "sumo"
*.manager.ignoreGuiCommands = true
#force the config name in the output file to be the same as for the gui experiment
output-vector-file = ${resultdir}/IntersectionMerge_${initialPositionDeltaA}_${initialPositionDeltaB}_${initialPositionDeltaC}_${dummyDelay}_${maxSpeed}_${repetition}.vec
output-scalar-file = ${resultdir}/IntersectionMerge_${initialPositionDeltaA}_${initialPositionDeltaB}_${initialPositionDeltaC}_${dummyDelay}_${maxSpeed}_${repetition}.sca

