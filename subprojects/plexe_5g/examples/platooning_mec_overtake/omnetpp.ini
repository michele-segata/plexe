[General]
cmdenv-express-mode = true
cmdenv-autoflush = true
cmdenv-status-frequency = 10s
num-rngs = 9

ned-path = .
network = PlatooningOvertakeMEC
eventlog-file=${resultdir}/${configname}-${repetition}.elog
snapshot-file=${resultdir}/${configname}-${repetition}.sna

repeat = 1

##########################################################
#            Simulation parameters                       #
##########################################################
debug-on-errors = true
print-undisposed = true

*.playgroundSizeX = 65000m
*.playgroundSizeY = 25000m
*.playgroundSizeZ = 50m

sim-time-limit = 120 s

##########################################################
# Annotation parameters                                  #
##########################################################
*.annotations.draw = false

##########################################################
# Obstacle parameters                                    #
##########################################################
*.obstacles.debug = false

##########################################################
#            WorldUtility parameters                     #
##########################################################
*.world.useTorus = false
*.world.use2D = false

##########################################################
#            TraCIScenarioManager parameters             #
##########################################################
*.manager.updateInterval = 0.01s
*.manager.host = "localhost"
*.manager.moduleType = "org.car2x.plexe.subprojects.plexe_5g.PlatoonCarNR"
*.manager.moduleName = "node"
*.manager.moduleDisplayString = ""
*.manager.autoShutdown = true
*.manager.margin = 25

##########################################################
#            11p specific parameters                     #
#                                                        #
#                    NIC-Settings                        #
##########################################################
*.connectionManager.sendDirect = true
*.connectionManager.maxInterfDist = 2600m
*.connectionManager.drawMaxIntfDist = false

*.**.nic.mac1609_4.useServiceChannel = false

*.**.nic.mac1609_4.txPower = 100mW
*.**.nic.mac1609_4.bitrate = 6Mbps

*.**.nic.mac1609_4.useAcks = true
*.**.nic.mac1609_4.ackErrorRate = 0.0
*.**.nic.mac1609_4.frameErrorRate = 0.0

*.**.nic.phy80211p.minPowerLevel = -94dBm
*.**.nic.phy80211p.maxTXPower = 100mW
*.**.nic.phy80211p.useNoiseFloor = true
*.**.nic.phy80211p.noiseFloor = -95dBm
*.**.nic.phy80211p.decider = xmldoc("config.xml")
*.**.nic.phy80211p.analogueModels = xmldoc("config.xml")
*.**.nic.phy80211p.usePropagationDelay = true

##########################################################
#          Mobile network specific parameters            #
##########################################################

############### SCTP configuration ##################
**.sctp.nagleEnabled = false         # if true, transmission of small packets will be delayed on the X2
**.sctp.enableHeartbeats = false

############### General PHY parameters ##############
#**.downlink_interference = true
#**.uplink_interference = true
**.ueTxPower = 26dBm
**.eNodeBTxPower = 46dBm
**.targetBler = 0.01
**.blerShift = 5
**.fbPeriod = 40tti   # reports CQI every 40ms

############### IPv4 configurator config #################
# although there exists Ipv4NodeConfigurator, the module cannot assign IPs to dynamically generated nodes
# for such reason, it is necessary to use HostAutoConfigurator
*.node[*].ipv4.configurator.typename = "inet.networklayer.configurator.ipv4.HostAutoConfigurator"
# this parameter has nothing to deal with the name of the submodule "cellularNic"
# it is a name the interface is registered with in inet. By default, in IP2Nic, the name is set to "cellular"
*.node[*].ipv4.configurator.interfaces = "cellular"
*.node[*].ipv4.configurator.addressBase = "10.0.0.0"
*.node[*].ipv4.configurator.netmask = "255.0.0.0"
*.node[*].ipv4.configurator.mcastGroups = "224.0.0.1"

# tcp settings
**.tcp.typename = "Tcp"
**.tcp.advertisedWindow = 65535         # in bytes, corresponds with the maximal receiver buffer capacity (Note: normally, NIC queues should be at least this size)
**.tcp.tcpAlgorithmClass = "TcpReno"    # TcpReno/TcpTahoe/TcpNewReno/TcpNoCongestionControl/DumbTcp
**.tcp.sackSupport = true               # Selective Acknowledgment (RFC 2018, 2883, 3517) support (header option) (SACK will be enabled for a connection if both endpoints support it)


############### CA configuration #################
*.carrierAggregation.numComponentCarriers = 1
*.carrierAggregation.componentCarrier[0].numerologyIndex = ${u=0}
*.carrierAggregation.componentCarrier[0].carrierFrequency = 2GHz
*.carrierAggregation.componentCarrier[0].numBands = ${numRbs=50}

*.gnb*.cellularNic.numCarriers = 1
*.gnb*.cellularNic.channelModel[0].componentCarrierIndex = 0
*.node[*].cellularNic.numCarriers = 1
*.node[*].cellularNic.nrChannelModel[0].componentCarrierIndex = 0

############### BS position #################
*.gnb*.mobility.initFromDisplayString = false

*.gnb1.mobility.initialX = 0m
*.gnb1.mobility.initialY = 224m
*.gnb2.mobility.initialX = 1400m
*.gnb2.mobility.initialY = 224m

############### X2 configuration #################
*.gnb*.numX2Apps = 1                                        # one x2App per peering node
*.gnb*.x2App[*].server.localPort = 5000 + ancestorIndex(1)  # Server ports (x2App[0]=5000, x2App[1]=5001, ...)
*.gnb1.x2App[0].client.connectAddress = "gnb2%x2ppp0"
*.gnb2.x2App[0].client.connectAddress = "gnb1%x2ppp0"

############## UE configuration ##################
# UEs associates to the best BS at the beginning of the simulation
# Enable dynamic association of UEs (based on best SINR)
*.node[*].masterId = 0     # ignored if dynamic association is disabled
*.node[*].macCellId = 0    # ignored if dynamic association is disabled
*.node[*].nrMasterId = 1     # ignored if dynamic association is disabled
*.node[*].nrMacCellId = 1    # ignored if dynamic association is disabled
**.dynamicCellAssociation = true
**.enableHandover = true

*.gnb*.cellularNic.phy.handoverLatency = 50ms
*.gnb*.cellInfo.broadcastMessageInterval = 1s # eNB will sends broadcast triggers every second

# eNodeB configuration
**.gnb1.macCellId = 1
**.gnb1.macNodeId = 1
**.gnb2.macCellId = 2
**.gnb2.macNodeId = 2

### Enable D2D for the eNodeB and the UEs involved in direct communications ###
**.amcMode = "D2D"

### Select CQI for D2D transmissions ###
# One-to-Many communications work with fixed CQI values only.
# Set the parameter **.usePreconfiguredTxParams and select the desired CQI using the parameter **.d2dCqi
**.enableD2DCqiReporting = false
**.usePreconfiguredTxParams = true
**.d2dCqi = ${cqi=7}


############ MEC Configuration ############


# MEC Hosts
**.mecHost*.virtualisationInfrastructure.ipv4.forwarding = true
*.mecHost1.maxMECApps = 1					# max ME Apps to instantiate
*.mecHost2.maxMECApps = 1					# max ME Apps to instantiate
*.mecHost*.maxRam = 32GB					# max KBytes of Ram
*.mecHost*.maxDisk = 100TB					# max KBytes of Disk Space
*.mecHost1.maxCpuSpeed = 400000		    	# max CPU
*.mecHost2.maxCpuSpeed = 400000				# max CPU

*.mecHost*.bsList = "gnb1, gnb2"

# MEC Services
# MEC host 1 services configurations
*.mecHost1.mecPlatform.numMecServices = 0
*.mecHost1.mecPlatform.mecService[0].typename = "LocationService"
*.mecHost1.mecPlatform.mecService[0].localAddress = "mecHost1.virtualisationInfrastructure"
*.mecHost1.mecPlatform.mecService[0].localPort = 10020
*.mecHost1.mecPlatform.serviceRegistry.localAddress = "mecHost1.virtualisationInfrastructure"
*.mecHost1.mecPlatform.serviceRegistry.localPort = 10021


# MEC host 2 services configurations
*.mecHost2.mecPlatform.numMecServices = 1
*.mecHost2.mecPlatform.mecService[0].typename = "LocationService"
*.mecHost2.mecPlatform.mecService[0].localAddress = "mecHost2.virtualisationInfrastructure"
*.mecHost2.mecPlatform.mecService[0].localPort = 10020
*.mecHost2.mecPlatform.serviceRegistry.localAddress = "mecHost2.virtualisationInfrastructure"
*.mecHost2.mecPlatform.serviceRegistry.localPort = 10021

# random number generators configuration
# TODO: fix to avoid clashing with oder RNGs
*.mecHost2.mecPlatform.serviceRegistry.rng-0 = 0 # request service time
*.mecHost2.mecPlatform.serviceRegistry.rng-1 = 1 # subscription service time
*.mecHost2.mecPlatform.mecService[0].rng-0 = 0 # request service time
*.mecHost2.mecPlatform.mecService[0].rng-1 = 1 # subscription service time
*.mecHost2.mecPlatform.mecService[0].requestServiceTime = 20us
*.mecHost2.mecPlatform.mecService[0].subscriptionServiceTime = 11us

# MEC Orchestrator configuration
*.mecOrchestrator.mecHostList = "mecHost1, mecHost2"              # MEC hosts associated to the MEC system
# *.mecOrchestrator.selectionPolicy = ${mecHostSelectionPolicy= "MecServiceBased", "MecHostBased", "AvailableResourcesBased"}
*.mecOrchestrator.selectionPolicy = ${mecHostSelectionPolicy= "AvailableResourcesBased"}
*.mecOrchestrator.mecHostIndex = 1
*.mecOrchestrator.mecApplicationPackageList = "OvertakeApp"   # List of MEC app descriptors to be onboarded at
*.mecHost*.mecPlatformManager.mecOrchestrator = "mecOrchestrator" # the MECPM needs to know the MEC orchestrator
















##########################################################
#                      Mobility                          #
##########################################################
*.node[*].mobility.x = 0
*.node[*].mobility.y = 0
*.node[*].mobility.z = 1.895
*.node[*].mobility.initFromDisplayString = true

*.node[*].traciMobility.x = 0
*.node[*].traciMobility.y = 0
*.node[*].traciMobility.z = 1.895

##########################################################
#                    Seeds and PRNGs                     #
##########################################################
seed-set = ${repetition}
**.seed = ${repetition}

*.node[*].prot.rng-0 = 5
*.node[*].appl.rng-0 = 6
*.node[*].scenario.rng-0 = 7
**.traffic.rng-0 = 8


#launch config. tells Veins which SUMO configuration to run
*.manager.configFile = "./sumocfg/overtake.sumo.cfg"
# *.manager.launchConfig = xmldoc("./sumocfg/indy.launchd.xml")

##########################################################
#                   Common parameters                    #
##########################################################

**.numberOfCars = ${nCars = 8}
**.numberOfCarsPerPlatoon = ${platoonSize = 4}
**.numberOfLanes = ${nLanes = 1}

##########################################################
#                    Position helper                     #
##########################################################

*.node[*].helper_type = "PositionHelper"

##########################################################
#               Scenario common parameters               #
##########################################################

#controller and engine related parameters
*.node[*].scenario.caccC1 = 0.5
*.node[*].scenario.caccXi = 1
*.node[*].scenario.caccOmegaN = 0.2 Hz
*.node[*].scenario.engineTau = 0 s
*.node[*].scenario.ploegH = 0.5s
*.node[*].scenario.ploegKp = 0.2
*.node[*].scenario.ploegKd = 0.7
*.node[*].scenario.useRealisticEngine = false
#via wireless send acceleration computed by the controller, not the actual one
*.node[*].scenario.useControllerAcceleration = true
*.node[*].scenario.nLanes = ${nLanes}

#controllers to be tested
*.node[*].scenario.targetController = "CACC"

#headway for ACCs
*.node[*].scenario.accHeadway = 0.1s
*.node[*].scenario.leaderHeadway = ${leaderHeadway = 1.2}s

#average leader speed
*.node[*].scenario.leaderSpeed = 100 kmph

##########################################################
#                      Application                       #
##########################################################

*.node[*].appl_type = "GeneralPlatooningApp"
#enable statistics recording for the application
*.node[*].appl.*.scalar-recording = true
*.node[*].appl.*.vector-recording = false
#use the join at back implementation of the join maneuver
*.node[*].appl.joinManeuver = "JoinAtBack"
*.node[*].appl.mergeManeuver = "MergeAtBack"

##########################################################
#                Communication protocols                 #
##########################################################

*.node[*].protocol_type = "SimplePlatooningBeaconing"
#enable statistics recording for the network layer
*.node[*].prot.*.scalar-recording = false
*.node[*].prot.*.vector-recording = false
#set the beaconing interval to be 0.1s
*.node[*].prot.beaconingInterval = 0.1s
#access category for platooning beacons
*.node[*].prot.priority = 4
#packet size for platooning beacon
*.node[*].prot.packetSize = 200

##########################################################
#                    Traffic manager                     #
##########################################################

**.traffic_type = "OvertakeTrafficManager"
#insert platooning vehicles at time
**.traffic.platoonInsertTime = 0.1 s
#SUMO vtype for platooning vehicles
**.traffic.platooningVType = "vtypeauto"
#controllers to be tested
**.numericController = ${controller = 0}
#insert vehicles already at steady-state. distance depends on controller
**.traffic.platoonInsertDistance = 5m
**.traffic.platoonInsertHeadway = 0s
**.traffic.platoonLeaderHeadway = ${leaderHeadway}s

#insert platooning vehicles with a speed of
**.traffic.platoonASpeed = ${overtookSpeed = 50kmph}
#**.traffic.platoonBSpeed = ${pBSpeed = 100, 100, 60 ! controller}kmph
**.traffic.platoonBSpeed = ${overtakeSpeed = 70kmph}
**.traffic.platoonCSpeed = ${incomingSpeed = 45}kmph

**.traffic.platoonSizeA = 2
**.traffic.platoonSizeB = 1
**.traffic.platoonSizeC = 1
**.traffic.initialPositionDeltaA = 150 
#**.traffic.initialPositionDeltaB = ${pDeltaB = 50, 70, }
**.traffic.initialPositionDeltaB = ${overtakingPosition=50}
#**.traffic.initialPositionDeltaC = ${pDeltaC = 480, 480, 490, 500, 510, 520} 
#**.traffic.initialPositionDeltaC = ${incomingPosition = 222}
**.traffic.initialPositionDeltaC = ${incomingPosition = 100..300 step 10}
**.traffic.controller = "CACC"

##########################################################
#                       INET stack                       #
##########################################################

# each car has a device app to instantiate the MEC app, and the UE Traffic Authority App
*.node[*].numApps = 2

*.node[*].app[0].typename = "DeviceApp"
*.node[*].app[0].localPort = 4500
*.node[*].app[0].UALCMPAddress = "ualcmp"
*.node[*].app[0].UALCMPPort = 1000
*.node[*].app[0].appPackageSource = "ApplicationDescriptors/OvertakeApp.json"

*.node[*].app[1].typename = "UEOvertakeApp"
*.node[*].app[1].deviceAppAddress = "node["+string(ancestorIndex(1))+"]"
*.node[*].app[1].deviceAppPort = 4500
*.node[*].app[1].deviceAppId = 19485 # just a random id
*.node[*].app[1].localPort = 4000
*.node[*].app[1].multicastPort = 5000
*.node[*].app[1].startTime = 2s
*.node[*].app[1].sendUpdateInterval = 0.1s
*.node[*].app[1].sendStartOvertakeTime = 5s
*.node[*].app[1].overtakeSpeed = ${overtakeSpeed}
*.node[*].app[1].overtakeAcceleration = 1.5 mpsps
# stop time is currently not used
*.node[*].app[1].stopTime = 120s
# name of the global module helping the translation from vehicle ID to IP address
*.node[*].app[1].idipModule = "idip"

*.node[*].app[1].*.scalar-recording = true
*.node[*].app[1].*.vector-recording = true


*.node[*].app[2].typename = "DeviceApp"
*.node[*].app[2].localPort = 4501
*.node[*].app[2].UALCMPAddress = "ualcmp"
*.node[*].app[2].UALCMPPort = 1000
*.node[*].app[2].appPackageSource = "ApplicationDescriptors/OvertakeApp.json"

*.node[*].app[3].typename = "UEOvertakeApp"
*.node[*].app[3].deviceAppAddress = "node["+string(ancestorIndex(1))+"]"
*.node[*].app[3].deviceAppPort = 4501
*.node[*].app[3].deviceAppId = 29481 # just a random id, but different from the one of app[1]
*.node[*].app[3].localPort = 4001
*.node[*].app[3].multicastPort = 5001
*.node[*].app[3].startTime = 2s
*.node[*].app[3].sendUpdateInterval = 1s
*.node[*].app[3].sendStartOvertakeTime = 5s
*.node[*].app[3].overtakeSpeed = ${overtakeSpeed}
*.node[*].app[3].overtakeAcceleration = 1.5 mpsps
# stop time is currently not used
*.node[*].app[3].stopTime = 120s

*.node[*].app[3].*.scalar-recording = true
*.node[*].app[3].*.vector-recording = true

*.mecHost*.MECOvertakeApp*.*.scalar-recording = true
*.mecHost*.MECOvertakeApp*.*.vector-recording = true

# parameters for the MEC-side application
#*.mecHost*.MECOvertakeApp*.rho = ${rho = 0.9}
*.mecHost*.MECOvertakeApp*.epsilon = 20 m
*.mecHost*.MECOvertakeApp*.v3 = ${incomingSpeed} kmph
# *.mecHost*.MECOvertakeApp*.useCooperativeOvertake = true
*.mecHost*.MECOvertakeApp*.migrator = "false"

#*.migrator.migrationDuration = 2s
#*.migrator.firstActiveHost = "mecHost1"

#------------------------------------#

# the old traffic authority is left just for old reference but it is not used
# it is now substituted by the MECTrafficAuthorityApp
*.trafficAuthority.numApps = 1
*.trafficAuthority.app[0].typename = "PlatoonTrafficAuthority"
*.trafficAuthority.app[0].localPort = 3000

#disable statistics recording for all other modules
**.scalar-recording = false
**.vector-recording = false

[Config BaselineOvertake]

repeat = 1

*.mecHost*.MECOvertakeApp*.useCooperativeOvertake = false
*.mecHost*.MECOvertakeApp*.delay = -1s
*.mecHost*.MECOvertakeApp*.rho = 1

*.manager.command = "sumo-gui"

#use the base scenario
*.node[*].scenario_type = "OvertakeScenario"

output-vector-file = ${resultdir}/${configname}_${overtakingPosition}_${incomingPosition}_${repetition}.vec
output-scalar-file = ${resultdir}/${configname}_${overtakingPosition}_${incomingPosition}_${repetition}.sca

[Config BaselineOvertakeNoGui]
extends = BaselineOvertake

*.mecHost*.MECOvertakeApp*.useCooperativeOvertake = false
*.mecHost*.MECOvertakeApp*.delay = -1s
*.mecHost*.MECOvertakeApp*.rho = 1

*.manager.command = "sumo"
*.manager.ignoreGuiCommands = true

output-vector-file = ${resultdir}/BaselineOvertake_${overtakingPosition}_${incomingPosition}_${repetition}.vec
output-scalar-file = ${resultdir}/BaselineOvertake_${overtakingPosition}_${incomingPosition}_${repetition}.sca

[Config Test]
extends = BaselineOvertake

*.mecHost*.MECOvertakeApp*.useCooperativeOvertake = true
*.mecHost*.MECOvertakeApp*.delay = -1s
*.mecHost*.MECOvertakeApp*.rho = 0.8

output-vector-file = ${resultdir}/${configname}_${repetition}.vec
output-scalar-file = ${resultdir}/${configname}_${repetition}.sca

[Config Overtake]
extends = BaselineOvertake

repeat = 10

*.mecHost*.MECOvertakeApp*.useCooperativeOvertake = true
**.dummyDelay = ${dummyDelay = 0, 1, 2, 3, 4}
*.mecHost*.MECOvertakeApp*.delay = ${-1s, uniform(0.1s, 0.2s), uniform(0.2s, 0.5s), uniform(0.5s, 1s), uniform(1s, 2s) ! dummyDelay}
*.mecHost*.MECOvertakeApp*.rho = ${rho = 0.8, 0.9}

output-vector-file = ${resultdir}/${configname}_${dummyDelay}_${rho}_${overtakingPosition}_${incomingPosition}_${repetition}.vec
output-scalar-file = ${resultdir}/${configname}_${dummyDelay}_${rho}_${overtakingPosition}_${incomingPosition}_${repetition}.sca

[Config OvertakeNoGui]
extends = Overtake

*.manager.command = "sumo"
*.manager.ignoreGuiCommands = true
#force the config name in the output file to be the same as for the gui experiment
output-vector-file = ${resultdir}/Overtake_${dummyDelay}_${rho}_${overtakingPosition}_${incomingPosition}_${repetition}.vec
output-scalar-file = ${resultdir}/Overtake_${dummyDelay}_${rho}_${overtakingPosition}_${incomingPosition}_${repetition}.sca
